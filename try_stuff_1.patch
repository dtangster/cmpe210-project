diff --git a/mininet/topology.py b/mininet/topology.py
index b004743..9af7eb9 100755
--- a/mininet/topology.py
+++ b/mininet/topology.py
@@ -46,9 +46,17 @@ def simple_topology():
     net.addLink(h22, s2)
     net.addLink(s1, s2)
 
+    output = h12.cmd('iperf -s -i 1 -u')
+    info("*** DAVID FIRST OUTPUT: ", output)
+    output = h11.cmd('iperf -c 10.0.0.12 -u -b 1000k -t 10')
+    info("*** DAVID SECOND OUTPUT: ", output)
+
     info('*** Starting network\n')
     net.start()
 
+    #for host in net.hosts:
+    #    host.cmd('/usr/sbin/sshd -D -o UseDNS=no -u0  &')
+
     while True:
         sleep(5)
 
diff --git a/ryu/controller.py b/ryu/controller.py
index a5768b3..2e5da88 100644
--- a/ryu/controller.py
+++ b/ryu/controller.py
@@ -1,6 +1,132 @@
-from ryu.app.simple_switch_13 import SimpleSwitch13
-from ryu.app.ofctl_rest import RestStatsApi
+from ryu.base import app_manager
+from ryu.controller import ofp_event
+from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
+from ryu.controller.handler import set_ev_cls
+from ryu.ofproto import ofproto_v1_3
+from ryu.lib.packet import packet
+from ryu.lib.packet import ethernet
+from ryu.lib.packet import ether_types
 
 
-class QosController(RestStatsApi, SimpleSwitch13):
-    pass
+class SimpleSwitch13(app_manager.RyuApp):
+    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]
+
+    def __init__(self, *args, **kwargs):
+        super(SimpleSwitch13, self).__init__(*args, **kwargs)
+        self.mac_to_port = {}
+
+    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
+    def switch_features_handler(self, ev):
+        datapath = ev.msg.datapath
+        ofproto = datapath.ofproto
+        parser = datapath.ofproto_parser
+
+        match = parser.OFPMatch()
+        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER)]
+
+        self.add_flow(datapath, 0, match, actions)
+
+        # add rule for metering in s1
+        if ev.msg.datapath.id==1:
+            datapath = ev.msg.datapath
+            ofproto = datapath.ofproto
+            parser = datapath.ofproto_parser
+
+            bands = [
+                parser.OFPMeterBandDrop(
+                    type_=ofproto.OFPMBT_DROP,
+                    len_=0, rate=100, burst_size=10
+                )
+            ]
+            req=parser.OFPMeterMod(
+                datapath=datapath,
+                command=ofproto.OFPMC_ADD,
+                flags=ofproto.OFPMF_KBPS,
+                meter_id=1,
+                bands=bands
+            )
+
+            self.logger.info("DAVID WAS HERE")
+            datapath.send_msg(req)
+
+            #when the traffic generated from h1 will be applied to meter_id=1
+            match = parser.OFPMatch(in_port=1, eth_type=0x0800)
+            #match = parser.OFPMatch(in_port=1, eth_type=0x0800, ipv4_src="10.0.0.1", ipv4_dst="10.0.0.2")
+            actions = [parser.OFPActionOutput(2)]
+            inst = [
+                parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions),
+                parser.OFPInstructionMeter(1,ofproto.OFPIT_METER)
+            ]
+            mod = datapath.ofproto_parser.OFPFlowMod(
+                datapath=datapath, match=match, cookie=0,
+                command=ofproto.OFPFC_ADD, idle_timeout=0,
+                hard_timeout=0, priority=3, instructions=inst
+            )
+
+            datapath.send_msg(mod)
+
+    def add_flow(self, datapath, priority, match, actions, buffer_id=None):
+        ofproto = datapath.ofproto
+        parser = datapath.ofproto_parser
+
+        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,
+                                             actions)]
+        if buffer_id:
+            mod = parser.OFPFlowMod(datapath=datapath, buffer_id=buffer_id,
+                                    priority=priority, match=match,
+                                    instructions=inst)
+        else:
+            mod = parser.OFPFlowMod(datapath=datapath, priority=priority,
+                                    match=match, instructions=inst)
+        datapath.send_msg(mod)
+
+    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
+    def _packet_in_handler(self, ev):
+        msg = ev.msg
+        datapath = msg.datapath
+        ofproto = datapath.ofproto
+        parser = datapath.ofproto_parser
+        in_port = msg.match['in_port']
+
+        pkt = packet.Packet(msg.data)
+        eth = pkt.get_protocols(ethernet.ethernet)[0]
+
+        if eth.ethertype == ether_types.ETH_TYPE_LLDP:
+            return
+
+        dst = eth.dst
+        src = eth.src
+
+        dpid = datapath.id
+        self.mac_to_port.setdefault(dpid, {})
+
+        self.logger.info("packet in %s %s %s %s", dpid, src, dst, in_port)
+
+        # learn a mac address to avoid FLOOD next time.
+        self.mac_to_port[dpid][src] = in_port
+
+        if dst in self.mac_to_port[dpid]:
+            out_port = self.mac_to_port[dpid][dst]
+        else:
+            out_port = ofproto.OFPP_FLOOD
+
+        actions = [parser.OFPActionOutput(out_port)]
+
+        # install a flow to avoid packet_in next time
+        if out_port != ofproto.OFPP_FLOOD:
+            match = parser.OFPMatch(in_port=in_port, eth_dst=dst, eth_src=src)
+            # verify if we have a valid buffer_id, if yes avoid to send both
+            # flow_mod & packet_out
+            if msg.buffer_id != ofproto.OFP_NO_BUFFER:
+                self.add_flow(datapath, 1, match, actions, msg.buffer_id)
+                return
+            else:
+                self.add_flow(datapath, 1, match, actions)
+        data = None
+        if msg.buffer_id == ofproto.OFP_NO_BUFFER:
+            data = msg.data
+
+        out = parser.OFPPacketOut(datapath=datapath, buffer_id=msg.buffer_id,
+                                  in_port=in_port, actions=actions, data=data)
+        datapath.send_msg(out)
+
